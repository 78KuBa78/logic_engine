#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <regex>
#include <set>
#include <unordered_map>
#include <stack>
#include <vector>
#include <cctype>

using namespace std;

bool isOperator(const string& token) {
    static const set<string> ops = { "AND", "OR", ">", "<", "==", "!=", ">=", "<=",
                                    "and", "or" };
    return ops.count(token) > 0;
}

bool isParen(const string& token) {
    return token == "(" || token == ")";
}

bool isKeyword(const string& token) {
    return isOperator(token) || isParen(token);
}

set<string> extractVariables(const string& input) {
    set<string> vars;
    regex re(R"(\b[A-Za-z_][A-Za-z0-9_]*\b)");
    sregex_iterator iter(input.begin(), input.end(), re), end;

    while (iter != end) {
        string var = iter->str();
        if (!isKeyword(var)) {
            vars.insert(var);
        }
        ++iter;
    }
    return vars;
}

unordered_map<string, string> promptVariableValues(const set<string>& vars) {
    unordered_map<string, string> values;
    for (const auto& var : vars) {
        cout << "Введите значение для " << var << ": ";
        string val;
        cin >> val;
        values[var] = val;
    }
    return values;
}

string replaceVariables(string input, const unordered_map<string, string>& values) {
    regex re(R"(\b[A-Za-z_][A-Za-z0-9_]*\b)");
    sregex_iterator iter(input.begin(), input.end(), re), end;

    string result;
    size_t lastPos = 0;

    while (iter != end) {
        size_t start = iter->position();
        size_t len = iter->length();
        string var = iter->str();

        result += input.substr(lastPos, start - lastPos);

        if (values.count(var)) {
            result += values.at(var);
        }
        else {
            result += var;
        }

        lastPos = start + len;
        ++iter;
    }

    result += input.substr(lastPos);
    return result;
}

int getPrecedence(const string& op) {
    if (op == "OR" || op == "or") return 1;
    if (op == "AND" || op == "and") return 2;
    if (op == "==" || op == "!=" || op == ">" || op == "<" || op == ">=" || op == "<=") return 3;
    return 0;
}

vector<string> tokenize(const string& expr) {
    vector<string> tokens;
    size_t i = 0;
    while (i < expr.length()) {
        if (isspace(expr[i])) {
            ++i;
            continue;
        }

        // Обработка отрицательных чисел
        if ((isdigit(expr[i]) ||
            (expr[i] == '-' &&
                (i == 0 || expr[i - 1] == '(' || isOperator(tokens.empty() ? "" : tokens.back())) &&
                i + 1 < expr.length() && isdigit(expr[i + 1])))) {

            string num;
            if (expr[i] == '-') {
                num += expr[i++];
            }
            while (i < expr.length() && isdigit(expr[i])) {
                num += expr[i++];
            }
            tokens.push_back(num);
        }
        // Идентификаторы и логические операторы
        else if (isalpha(expr[i])) {
            string word;
            while (i < expr.length() && isalnum(expr[i])) {
                word += expr[i++];
            }
            tokens.push_back(word);
        }
        // Скобки и операторы сравнения
        else {
            string op(1, expr[i]);
            if ((i + 1 < expr.length()) && expr[i + 1] == '=') {
                op += expr[++i];
            }
            tokens.push_back(op);
            ++i;
        }
    }
    return tokens;
}



vector<string> toRPN(const vector<string>& tokens) {
    vector<string> output;
    stack<string> ops;

    for (const auto& tok : tokens) {
        if (isdigit(tok[0]) || (tok.length() > 1 && isdigit(tok[1]))) {
            output.push_back(tok);
        }
        else if (isOperator(tok)) {
            while (!ops.empty() && isOperator(ops.top()) &&
                getPrecedence(ops.top()) >= getPrecedence(tok)) {
                output.push_back(ops.top());
                ops.pop();
            }
            ops.push(tok);
        }
        else if (tok == "(") {
            ops.push(tok);
        }
        else if (tok == ")") {
            while (!ops.empty() && ops.top() != "(") {
                output.push_back(ops.top());
                ops.pop();
            }
            if (!ops.empty() && ops.top() == "(") {
                ops.pop();
            }
            else {
                throw runtime_error("Несоответствие скобок");
            }
        }
        else {
            throw runtime_error("Неизвестный токен: " + tok);
        }
    }

    while (!ops.empty()) {
        if (isParen(ops.top())) throw runtime_error("Несоответствие скобок");
        output.push_back(ops.top());
        ops.pop();
    }

    return output;
}

bool applyOp(int lhs, int rhs, const string& op) {
    if (op == "AND" || op == "and") return lhs && rhs;
    if (op == "OR" || op == "or") return lhs || rhs;
    if (op == "==") return lhs == rhs;
    if (op == "!=") return lhs != rhs;
    if (op == ">") return lhs > rhs;
    if (op == "<") return lhs < rhs;
    if (op == ">=") return lhs >= rhs;
    if (op == "<=") return lhs <= rhs;
    throw runtime_error("Неизвестная операция: " + op);
}

bool evaluateRPN(const vector<string>& rpn) {
    stack<int> st;
    for (const auto& tok : rpn) {
        if (isdigit(tok[0]) || (tok.length() > 1 && isdigit(tok[1]))) {
            st.push(stoi(tok));
        }
        else {
            if (st.size() < 2) throw runtime_error("Недостаточно операндов");
            int rhs = st.top(); st.pop();
            int lhs = st.top(); st.pop();
            st.push(applyOp(lhs, rhs, tok));
        }
    }
    if (st.size() != 1) throw runtime_error("Неверное выражение");
    return st.top();
}

void processExpression(const string& exprRaw) {
    try {
        set<string> vars = extractVariables(exprRaw);
        unordered_map<string, string> values = promptVariableValues(vars);
        string expr = replaceVariables(exprRaw, values);
        cout << "После подстановки: " << expr << endl;

        auto tokens = tokenize(expr);
        auto rpn = toRPN(tokens);
        bool result = evaluateRPN(rpn);
        cout << "Результат: " << boolalpha << result << endl;
    }
    catch (const exception& e) {
        cerr << "Ошибка в выражении: " << e.what() << endl;
    }
}

void runFromConsole() {
    cout << "Введите логическое выражение:\n";
    string expr;
    getline(cin, expr);
    processExpression(expr);
}

void runFromArg(const string& expr) {
    processExpression(expr);
}

void runFromFile(const string& filename) {
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Не удалось открыть файл.\n";
        return;
    }

    string line;
    int lineNum = 1;
    while (getline(file, line)) {
        if (line.empty()) continue;
        cout << "\nВыражение #" << lineNum++ << ": " << line << endl;
        processExpression(line);
    }
}

int main(int argc, char* argv[]) {
    setlocale(LC_ALL, "ru");

    cout << "Выберите режим:\n";
    cout << "1. Ввести выражение вручную\n";
    cout << "2. Ввести выражение аргументом при запуске\n";
    cout << "3. Загрузить выражения из файла\n";
    cout << "Ваш выбор: ";
    int choice;
    cin >> choice;
    cin.ignore();

    switch (choice) {
    case 1:
        runFromConsole();
        break;
    case 2:
        if (argc >= 2) {
            runFromArg(argv[1]);
        }
        else {
            cout << "Нет аргумента в командной строке.\n";
        }
        break;
    case 3: {
        cout << "Введите имя файла: ";
        string fname;
        getline(cin, fname);
        runFromFile(fname);
        break;
    }
    default:
        cout << "Неверный выбор.\n";
        break;
    }

    return 0;
}
